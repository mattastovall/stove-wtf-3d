import { useRef, useState, useEffect } from "react";
import { createRoot } from "react-dom/client";
import { Canvas, useFrame, useThree } from "@react-three/fiber";
import { useGLTF, Text } from '@react-three/drei';
import { useSpring, animated as a } from '@react-spring/three'; // Import useSpring and animated (as 'a')
import { throttle } from "lodash"; // Ensure lodash is correctly imported
import "./style.css";
import "./App.css";
import { PolygonjsScene } from "@polygonjs/react-three-fiber";
import { loadScene_scene_01 } from "./polygonjs/scenes/scene_01/autogenerated/loadScene";
import {
    PolySceneWithNodeMap_scene_01,
    PolySceneProps_scene_01,
} from "./polygonjs/scenes/scene_01/autogenerated/PolySceneWithNodeMap";

interface StoveLogoProps {
    position: [number, number, number];
}

function StoveLogo({ position }: StoveLogoProps) {
    const groupRef = useRef<THREE.Group>(null);
    const [hovered, setHovered] = useState(false);
    const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
    const easingFactor = 1;
    const [props, set] = useSpring(() => ({ scale: 1 }));
    let content; // Ensure 'content' is declared in the correct scope

    const handleClick = () => {
        set({ scale: 0.5, 
            config: { tension: 200, friction: 5 },
        });
        setTimeout(() => set({ scale: 1 }), 30);
    };


    useEffect(() => {
        const throttledMouseMove = throttle((event: MouseEvent) => { // Specify type for 'event'
            if (groupRef.current) {
                // Perform raycasting here
                // Set hovered state and mouse position if intersecting
            }
        }, 20); // Throttle mouse move event to limit frequency

        window.addEventListener('mousemove', throttledMouseMove);
        return () => window.removeEventListener('mousemove', throttledMouseMove);
    }, []);

    useFrame(() => {
        // Apply easing to the rotation if hovered
        if (groupRef.current && hovered) {
            groupRef.current.rotation.x += (mousePosition.y - groupRef.current.rotation.x) * easingFactor;
            groupRef.current.rotation.y += (mousePosition.x - groupRef.current.rotation.y) * easingFactor;
        }
    });

    try {
        const gltf = useGLTF('/textures/models/stovelogo.gltf') as any; // Using 'any' for now
        const { nodes, materials } = gltf;
        content = Object.keys(nodes).map((name) => (
            <primitive
                key={name}
                object={nodes[name]}
                material={materials[name]}
            />
        ));
    } catch (error) {
        console.error("Error loading GLTF model:", error);
        // Using Text from @react-three/drei for displaying error text
        content = <Text color="black" fontSize={1}>Error Loading Model</Text>;
    }

    return (
        <a.group ref={groupRef} position={position} dispose={null} scale={props.scale} onClick={handleClick}>
            {content}
        </a.group>
    );
}

function CameraController() {
    const { camera } = useThree();
    const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
    const [isPointerInside, setIsPointerInside] = useState(true);
    const defaultRotation = { x: 0, y: 0 }; // Define default rotation
    const easingFactor = Math.sin((1 - Math.abs(0.1 - camera.rotation.x)) * Math.PI / 80);

    useEffect(() => {
        const handleMouseMove = (event: MouseEvent) => {
            setMousePosition({
                x: -(event.clientX / window.innerWidth) * 2 + 1,
                y: -(event.clientY / window.innerHeight) * 2 + 1
            });
        };

        const handleMouseEnter = () => setIsPointerInside(true);
        const handleMouseLeave = () => setIsPointerInside(false);

        window.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('mouseenter', handleMouseEnter);
        window.addEventListener('mouseleave', handleMouseLeave);

        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseenter', handleMouseEnter);
            window.removeEventListener('mouseleave', handleMouseLeave);
        };
    }, []);

    useFrame(() => {
        // Determine target rotation based on mouse position or default
        const targetRotation = isPointerInside 
            ? { x: mousePosition.y * 0.8, y: mousePosition.x * 0.8 } 
            : defaultRotation;

        // Apply easing to the camera rotation
        camera.rotation.x += (targetRotation.x - camera.rotation.x) * easingFactor;
        camera.rotation.y += (targetRotation.y - camera.rotation.y) * easingFactor;
    });

    return null;
}


function App() {
    return (
        <Canvas camera={{ position: [0, 0, 10] }}>
            <CameraController />
            <ambientLight />
            <pointLight position={[10, 10, 10]} />
            <StoveLogo position={[0, 0, 0]} /> 
            <PolygonjsScene<PolySceneWithNodeMap_scene_01, PolySceneProps_scene_01>
                sceneName={"scene_01"}
                loadFunction={loadScene_scene_01}
                baseUrl={import.meta.env.BASE_URL}
            />
        </Canvas>
    );
}

createRoot(document.getElementById("app")!).render(<App />);

