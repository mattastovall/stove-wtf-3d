import { useRef, useState, useEffect } from "react";
import { createRoot } from "react-dom/client";
import { Canvas, useFrame, useThree } from "@react-three/fiber";
import { useGLTF, Text } from '@react-three/drei';
import { useSpring, animated as a } from '@react-spring/three';
import * as postprocessing from '@react-three/postprocessing'

import "./style.css";
import "./App.css";
import { PolygonjsScene } from "@polygonjs/react-three-fiber";
import * as THREE from 'three';
import { Raycaster, Vector2, Plane, Vector3 } from 'three';
import { loadScene_scene_01 } from "./polygonjs/scenes/scene_01/autogenerated/loadScene";
import {
    PolySceneWithNodeMap_scene_01,
    PolySceneProps_scene_01,
} from "./polygonjs/scenes/scene_01/autogenerated/PolySceneWithNodeMap";

// Interface for StoveLogoProps
interface StoveLogoProps {
    position: [number, number, number];
    meshRef: React.RefObject<THREE.Mesh>; // Add meshRef prop
}

const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 50);

// Spheres Component
function Spheres({ stoveLogoMesh }: { stoveLogoMesh: React.RefObject<THREE.Mesh> }) { // Add stoveLogoMesh prop
    const spheres = useRef<THREE.Mesh[]>([]);
    const [pointer, setPointer] = useState({ x: 0, y: 0, z: 0 });
    const raycasterRef = useRef(new THREE.Raycaster());

    // Pointer Move Handler
    const handlePointerMove = (event: MouseEvent) => {
        setPointer(prevState => ({
            x: (event.clientX / window.innerWidth) * 2 - 1,
            y: -(event.clientY / window.innerHeight) * 2 + 1,
            z: prevState.z
        }));
    };

    useEffect(() => {
        window.addEventListener('mousemove', handlePointerMove);

        // Clean up the event listener when the component is unmounted
        return () => {
            window.removeEventListener('mousemove', handlePointerMove);
        };
    }, []);

    useFrame(({ camera }) => {
        const vector = new Vector2(pointer.x, pointer.y);
        raycasterRef.current.setFromCamera(vector, camera);
        
        const target = new THREE.Vector3();
        raycasterRef.current.ray.intersectPlane(plane, target);
        
        // Update the position of the first sphere and make it visible
        if (spheres.current[0]) {
            spheres.current[0].position.copy(target);
            spheres.current[0].visible = true;
        }

        // Hide the other spheres
        for (let i = 1; i < spheres.current.length; i++) {
            if (spheres.current[i]) {
                spheres.current[i].visible = false;
            }
        }

        // Check for intersections with the StoveLogo
    });

    // Create Sphere Elements
    const sphereElements = [];
    for (let i = 0; i < 40; i++) {
        sphereElements.push(
            <mesh key={i} ref={el => spheres.current[i] = el!}>
                <sphereGeometry args={[10, 4, 2]} />
                <meshBasicMaterial color={0xff0000} wireframe={true} />
            </mesh>
        );
    }

    return <>{sphereElements}</>;
}


// StoveLogo Component
function StoveLogo({ position, meshRef }: StoveLogoProps) { // Add meshRef prop
    const groupRef = useRef<THREE.Group>(null);
    const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
    const easingFactor = Math.sin((1 - Math.abs(0.09 - 1)) * Math.PI / 20);
    const [props, set] = useSpring(() => ({ scale: 1 }));
    let content;

    // Click handler to animate scale
    const handleClick = () => {
        set({ scale: 0.5, 
            config: { tension: 100, friction: 10 },
        });
        setTimeout(() => set({ scale: 1 }), 30);
    };

    // Effect for handling mouse movement
    useEffect(() => {
        const handleMouseMove = (event: MouseEvent) => {
            setMousePosition({
                x: (event.clientX / window.innerWidth) * 2 - 1,
                y: (event.clientY / window.innerHeight) * 2 - 1
            });
        };

        window.addEventListener('mousemove', handleMouseMove);

        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
        };
    }, []);

    // Frame loop for updating rotation based on mouse position
    useFrame(() => {
        if (groupRef.current) {
            groupRef.current.rotation.x += (mousePosition.y - groupRef.current.rotation.x) * easingFactor;
            groupRef.current.rotation.y += (mousePosition.x - groupRef.current.rotation.y) * easingFactor;
        }
    });

    // Loading 3D model and handling errors
    try {
        const gltf = useGLTF('/textures/models/stovelogo.gltf') as any;
        const { nodes } = gltf;
        content = Object.keys(nodes).map((name) => (
            <primitive
                key={name}
                object={nodes[name]}
            >
                <meshStandardMaterial    
                    attach="material"
                    color="black"
                    roughness={0.4}
                    metalness={0.6}
                    />
            </primitive>
        ));
    } catch (error) {
        console.error("Error loading GLTF model:", error);
        content = <Text color="black" fontSize={1}>Error Loading Model</Text>;
    }

    // Rendering the 3D model with animations
    return (
        <a.group ref={groupRef} position={position} dispose={null} scale={props.scale} onClick={handleClick}>
            <mesh ref={meshRef}>
                {content}
            </mesh>
        </a.group>
    );
}

function CameraController() {
    const { camera } = useThree();
    const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
    const [isPointerInside, setIsPointerInside] = useState(true);
    const defaultRotation = { x: 0, y: 0 }; // Define default rotation
    const easingFactor = Math.sin((1 - Math.abs(0.1 - camera.rotation.x)) * Math.PI / 3500);

    useEffect(() => {
        const handleMouseMove = (event: MouseEvent) => {
            setMousePosition({
                x: -(event.clientX / window.innerWidth) * 2 + 1,
                y: -(event.clientY / window.innerHeight) * 2 + 1
            });
        };

        const handleMouseEnter = () => setIsPointerInside(true);
        const handleMouseLeave = () => setIsPointerInside(false);

        window.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('mouseenter', handleMouseEnter);
        window.addEventListener('mouseleave', handleMouseLeave);

        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseenter', handleMouseEnter);
            window.removeEventListener('mouseleave', handleMouseLeave);
        };
    }, []);

    useFrame(() => {
        // Determine target rotation based on mouse position or default
        const targetRotation = isPointerInside 
            ? { x: mousePosition.y * 0.1, y: mousePosition.x * 0.1 } 
            : defaultRotation;

        // Apply easing to the camera rotation
        camera.rotation.x += (targetRotation.x - camera.rotation.x) * easingFactor;
        camera.rotation.y += (targetRotation.y - camera.rotation.y) * easingFactor;
    });

    return null;
}


function App() {
    const raycasterRef = useRef(new Raycaster());
    raycasterRef.current.ray.origin.set(0, 0, 50);
    const stoveLogoMesh = useRef<THREE.Mesh>(null); // Add this line

    useEffect(() => {
        // Initialize raycaster parameters when the component mounts
        raycasterRef.current.params.Mesh = { threshold: 0 };
    }, []);

    const handlePointerMove = () => {
        // Check if Points is defined and then set the threshold
        if (raycasterRef.current?.params?.Mesh) {
            raycasterRef.current.params.Mesh.threshold = 800; // Adjust this value as needed
        }
    };
    return (
        <>
        
            <Canvas 
                camera={{ position: [0, 0, 0.5], fov: 8 }} // Add fov property
                onPointerMove={handlePointerMove}
                raycaster={raycasterRef.current}
            >
                <CameraController />
                <ambientLight />
                <pointLight position={[10, 10, 10]} />
                <StoveLogo position={[-0.22, -0.35, -10]} meshRef={stoveLogoMesh} /> {/* Pass the meshRef */}
                <PolygonjsScene<PolySceneWithNodeMap_scene_01, PolySceneProps_scene_01>
                    sceneName={"scene_01"}
                    loadFunction={loadScene_scene_01}
                    baseUrl={import.meta.env.BASE_URL}
                />
                <Spheres stoveLogoMesh={stoveLogoMesh} />
                <postprocessing.EffectComposer>
                    <postprocessing.Scanline density={0.8}/>
                    <postprocessing.Bloom intensity={500.5} luminanceThreshold={0.2} luminanceSmoothing={0.5} radius={100} />
                </postprocessing.EffectComposer> {/* Pass the meshRef */}
            </Canvas>
        </>
    );
}

const root = createRoot(document.getElementById("app")!);
root.render(<App />);
