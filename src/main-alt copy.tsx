import { useRef, useState, useEffect } from "react";
import { createRoot } from "react-dom/client";
import { Canvas, useFrame, useThree } from "@react-three/fiber";
import { useGLTF, Text } from '@react-three/drei';
import { useSpring, animated as a } from '@react-spring/three';
import { throttle } from "lodash";
import { Raycaster, Vector2 } from 'three';
import "./style.css";
import "./App.css";
import { PolygonjsScene } from "@polygonjs/react-three-fiber";
import { loadScene_scene_01 } from "./polygonjs/scenes/scene_01/autogenerated/loadScene";
import {
    PolySceneWithNodeMap_scene_01,
    PolySceneProps_scene_01,
} from "./polygonjs/scenes/scene_01/autogenerated/PolySceneWithNodeMap";

// Interface for StoveLogoProps
interface StoveLogoProps {
    position: [number, number, number];
}

// StoveLogo Component
function StoveLogo({ position }: StoveLogoProps) {
    const groupRef = useRef<THREE.Group>(null);
    const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
    const easingFactor = 1; // Control the rate of easing
    const [props, set] = useSpring(() => ({ scale: 1 }));
    let content;

    // Click handler to animate scale
    const handleClick = () => {
        set({ scale: 0.5, 
            config: { tension: 200, friction: 5 },
        });
        setTimeout(() => set({ scale: 1 }), 30);
    };

    // Effect for handling mouse movement
    useEffect(() => {
        const handleMouseMove = (event: MouseEvent) => {
            setMousePosition({
                x: (event.clientX / window.innerWidth) * 2 - 1,
                y: (event.clientY / window.innerHeight) * 2 - 1
            });
        };

        window.addEventListener('mousemove', handleMouseMove);

        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
        };
    }, []);

    // Frame loop for updating rotation based on mouse position
    useFrame(() => {
        if (groupRef.current) {
            groupRef.current.rotation.x += (mousePosition.y - groupRef.current.rotation.x) * easingFactor;
            groupRef.current.rotation.y += (mousePosition.x - groupRef.current.rotation.y) * easingFactor;
        }
    });

    // Loading 3D model and handling errors
    try {
        const gltf = useGLTF('/textures/models/stovelogo.gltf') as any;
        const { nodes, materials } = gltf;
        content = Object.keys(nodes).map((name) => (
            <primitive
                key={name}
                object={nodes[name]}
                material={materials[name]}
            />
        ));
    } catch (error) {
        console.error("Error loading GLTF model:", error);
        content = <Text color="black" fontSize={1}>Error Loading Model</Text>;
    }

    // Rendering the 3D model with animations
    return (
        <a.group ref={groupRef} position={position} dispose={null} scale={props.scale} onClick={handleClick}>
            {content}
        </a.group>
    );
}

function CameraController() {
    const { camera } = useThree();
    const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
    const [isPointerInside, setIsPointerInside] = useState(true);
    const defaultRotation = { x: 0, y: 0 }; // Define default rotation
    const easingFactor = Math.sin((1 - Math.abs(0.1 - camera.rotation.x)) * Math.PI / 80);

    useEffect(() => {
        const handleMouseMove = (event: MouseEvent) => {
            setMousePosition({
                x: -(event.clientX / window.innerWidth) * 2 + 1,
                y: -(event.clientY / window.innerHeight) * 2 + 1
            });
        };

        const handleMouseEnter = () => setIsPointerInside(true);
        const handleMouseLeave = () => setIsPointerInside(false);

        window.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('mouseenter', handleMouseEnter);
        window.addEventListener('mouseleave', handleMouseLeave);

        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseenter', handleMouseEnter);
            window.removeEventListener('mouseleave', handleMouseLeave);
        };
    }, []);

    useFrame(() => {
        // Determine target rotation based on mouse position or default
        const targetRotation = isPointerInside 
            ? { x: mousePosition.y * 0.8, y: mousePosition.x * 0.8 } 
            : defaultRotation;

        // Apply easing to the camera rotation
        camera.rotation.x += (targetRotation.x - camera.rotation.x) * easingFactor;
        camera.rotation.y += (targetRotation.y - camera.rotation.y) * easingFactor;
    });

    return null;
}


function App() {
    return (
        <Canvas camera={{ position: [0, 0, 10] }}>
            <CameraController />
            <ambientLight />
            <pointLight position={[10, 10, 10]} />
            <StoveLogo position={[0, 0, 0]} /> 
            <PolygonjsScene<PolySceneWithNodeMap_scene_01, PolySceneProps_scene_01>
                sceneName={"scene_01"}
                loadFunction={loadScene_scene_01}
                baseUrl={import.meta.env.BASE_URL}
            />
        </Canvas>
    );
}

createRoot(document.getElementById("app")!).render(<App />);

